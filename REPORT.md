# 软件工程实训任务报告

@author  软件2001奚兆阳，GitHub：awaaaaaaaa

## 1.任务概述

### 1.1任务介绍

《World of Zuul》是一款简单的文本冒险游戏。用户可以在一些房间组成的迷宫中探险。现在需要通过扩展该游戏的功能使它更有趣!

### 1.2任务目标

1. 理解软件代码规范的重要性
2. 理解代码变化对软件质量带来的影响
3. 掌握基于Git的个人代码版本维护方法
4. 掌握markdown文件编写方法

## 2.任务分析

### 2.1任务重点

1. 阅读、理解和标注样例代码
2. 分析和学习代码质量特征、设计方法和编程风格
3. 运用所学方法，对开源代码进行标注
4. 对样例工程进行简单功能扩充和维护

### 2.2任务要求

#### 2.2.1 阅读和描述样例工程

- fork样例工程，并clone到本地仓库；
- 在本地开发环境上运行样例工程，理解样例工程的代码逻辑；
- 以UML图描述样例工程的组成及结构图（类及类之间的关系）
  - 可结合markdown语法和mermaid插件绘制所需图形标注样例工程中的代码


####  2.2.2标注样例工程中的代码

- 基于javadoc规范标注代码，对包、类、方法、代码片段、参数和语句等代码层次进行注释（可参考Game类的标注样例）；
- 注释后的代码提交到本地代码库后，同步推送到远程代码仓库；
- 可参考ESLint、GitHub/super-linter等开发插件了解关于代码规范的相关知识；

#### 2.2.3扩充和维护样例工程

- 对样例代码中的功能设计进行分析，找出若干设计缺陷和改进点，并进行修正或扩充，并集成到工程代码中；
- 可借助代码质量分析工具或代码规范检查工具对代码质量进行分析，发现潜在问题；

#### 2.2.4功能扩充点

- 样例工程“world-of-zuul”具备最基本的程序功能，该项目具有极大的扩展空间，各位同学可选择或自行设计系统结构优化或功能扩充需求，完成3项左右的功能扩充实现；

#### 2.2.5编写测试用例

- 针对功能改进和扩充，在项目结构中编写单元测试用例，对代码执行单元测试；

## 3.开发计划

### 3.1对项目示例代码进行建模

在fork仓库代码并clone到本地后,阅读代码后尝试理解实例代码的结构
并根据其中类的关系,利用Enterprise Architect软件绘制实例代码的UML类图

### 3.2维护样例工程

阅读样例代码后，发现如下几点问题，

1. 在Game类的processCommand()方法中，当用户输入的命令被辨认出来以后，有一系列的if语句用来分派程序到不同的地方去执行。从面向对象的设计原则来看，这种解决方案不太好，因为每当要加入一个新的命令时，就得在这一堆if语句中再加入一个if分支，最终会导致这个方法的代码膨胀得极其臃肿。

2. 在Game类中的createRooms方法中,使用了逐句赋值的方法来初始化地图,这种方法会造成文件内代码过多,同时修改地图也比较繁琐。

在接下来的开发过程中，将利用IDEA编辑器，结合所学的面向对象的知识和数据结构的知识尝试解决

### 3.3完成项目拓展功能

根据给出的样例功能实现，确定要增加的功能扩充实现需求如下：

1. 使得一个房间里可以存放任意数量的物件，每个物件可以有一个描述和一个重量值。
2. 在游戏中实现一个“back”命令。back指令可以实现回到起点，回退一步，回退指定步数，以及对回退的步数大于已经走的步数的错误处理。
3. 在游戏中增加具有传输功能的房间，每当玩家进入这个房间，就会被随机地传输到另一个房间。
4. 在游戏中新建一个独立的Player类用来表示玩家
   1. 一个玩家通过登录来进行游行，可以区分为初次登录和载入存档。存档可以通过数据库进行保存。
    2. 一个玩家对象应该保存玩家的姓名等基本信息，也应该保存玩家当前所在的房间。
    3. 玩家可以随身携带任意数量的物件，但随身物品的总重量不能操过某个上限值。
    4. 玩家可以拾取房间内的指定物品或丢弃身上携带的某件或全部物品，当拾取新的物件时超过了玩家可携带的重量上限，系统应给出提示。
    5. 在游戏中增加一个新的命令“items”, 可以打印出当前房间内所有的物件及总重量，以及玩家随身携带的所有物件及总重量。
    6. 在某个或某些房间中随机增加一个magic cookie（魔法饼干）物件，并增加一个“eat cookie”命令，如果玩家找到并吃掉魔法饼干，就可以增长玩家的负重能力，增加的重量视为魔法饼干本身的重量。

在确定要实现的需求后，我们便可以在IDEA编辑器中编写代码来实现需求。

### 3.4装配项目数据库与文件系统

由于项目采用的数据库是mysql, 对于数据库的编写在mysql的Workbench中完成。

同时在项目中增加java和mysql连接的配置jar包

### 3.5优化代码编写风格和结构

在全部功能基本实现后，利用IDEA内自带的代码检查功能对代码的格式和命名进行修改。
同时尽量保证新编写的代码和样例工程中的代码风格保持一致。

### 3.6对项目进行软件测试

在全部需求实现完成，同时对代码进行初步检查后，在IDEA编辑器内的插件JUnit来对项目进行软件测试，再根据检查的结果来修改bug或是优化代码。重复以上过程。

## 4.软件配置计划

### 4.1软件版本编码方案

采取最为广泛的“主版本号.子版本号.修正版本号”格式。详细规则如图所示:

[![YNE-DT40-Y-4-Z-FJX-I1-CV7.png](https://i.postimg.cc/L62bRrmC/YNE-DT40-Y-4-Z-FJX-I1-CV7.png)](https://postimg.cc/ThN9JNLg)

### 4.2命名规范

采用最广泛的驼峰规则，也就是变量名称首个单词小写，其余单词首字母大写。类的命名则采用每个单词首字母大写的形式。在实例化时则尽量让变量名称为变量类型的小写。

### 4.3分支管理规范

由于项目由个人独立开发，不用考虑将别人的代码进行合并的操作。一共使用两种类型的版本，-master和-develop。前者为可稳定使用的版本，后者为开发新功能的版本

- -master 分支（主分支） 稳定版本
- -develop 分支（开发分支） 最新版本

在对develop版本测试后没有发现问题，则将其推送为master版本。

### 4.4提交规范

计划使用基于 angular 规范的 commit

基于 angular 规范的 commit commit格式如下: <type>: <subject> <BLANK LINE> <body> type - 提交 commit 的类型 feat: 新功能 fix: 修复问题 docs: 修改文档 style: 修改代码格式(不影响逻辑功能,比如格式化.补充分号等等) refactor: 重构代码(fix bug或增加新功能不属于此范围) perf: 提升页面性能 test: 增加/修改测试用例 chore:

## 5.测试计划

利用Junit框架对项目中的基类中的非常规方法（即不包括get，set，show这类方法）进行白盒测试，对于不易于编写测试用例的，，需要大量与用户交互并依赖用户来进行结果分析的类（即Game类）中的方法，我们设计完整的测试流程对其进行黑盒测试。

## 6.实施情况

### 6.1绘制示例代码UML图

根据实例代码的类之间的关系，可以得到如下的UML类图

[![QQ-20230102233739.jpg](https://i.postimg.cc/gJP4WScW/QQ-20230102233739.jpg)](https://postimg.cc/SXDcLGzT)

### 6.2 维护样例工程

在3.2中我们已经讨论了对样例工程的那些地方进行修改，在这里将具体讨论如何实现

1. processCommand中采用if建立命令到函数的映射，该方法在添加一个新的命令时需要新增一个if分支，导致代码极其臃肿

   解决方法:通过使用Java8的新特性,建立一个String到函数的映射

```java
private final HashMap<String, Function<Command, Boolean>> commandList;
```

​		便可以通过读入的字符串来实现直接执行对应的函数,符合面向对象的思想

​		这样我们就可以直接使用HashMap来存储合法的命令,部分代码如下

```javascript
    commandList = new HashMap<>();
    commandList.put("help",this::printHelp);
    commandList.put("go",this::goRoom);
```

​		那么我们进行函数调用只需

```java
    private boolean processCommand(Command command){
        if(command.isUnknown()) {
            System.out.println("I don't know what you mean...");
            return true;
        }
        return commandList.get(command.getCommandWord()).apply(command);
    }
```

​		这样，在添加一个新的命令时，我们只需要在完善命令设计和对应的函数编写后直接在commandList中进行新增即可。

​		这种实现方式还有一个好处：当我们的项目越来越复杂，指令越来越多时，CommandWord类中的isUnknown方法因为采用循环遍历有效指令集的方式，效率会显著下降，这时我们可以利用该CommandList来进行快速查找，而不再需要使用isUnknown方法。

2. 原项目中将地图信息存储在代码内，这种做法在对于地图进行修改时极其不便，在新增地图时需要手动创建更多的对象，不仅不易于操作，而且会导致代码极其臃肿。

   解决办法：将地图信息从代码中分离出来，存储到文件中，在游戏运行前先在文件中读取地图。部分代码如下

```java
	FileReader fileReader = new FileReader("E:\\awaaaaaaaa\\src\\cn\\edu\\whut\\sept\\zuul\\GameMap.txt");
	BufferedReader bufferedReader = new BufferedReader(fileReader);
	String s;
	s=bufferedReader.readLine();
	this.roomNum=Integer.parseInt(s);
```

### 6.3 完成项目拓展功能

在3.3中我们已经讨论了增加哪些功能，在这里将具体讨论如何实现

1. 扩展物件。使得一个房间里可以存放任意数量的物件。

   创建Item类用于表示物品物件，在房间对象Room内创建一个存储物品对象的ArrayList<Item>属性items，同时在添加look作为合法指令，实现look方法以查看当前房间的信息以及房间内的所有物品信息；

2. “back”命令。玩家输入该命令后会把玩家带回上一个房间，重复使用它就可以逐层回退几个房间，直到把玩家带回到游戏的起点。

   在Room类中添加一个表示房间编号的属性id，在Game类中添加一个编号对房间的映射idRoomMap，建立一个栈的数据结构（项目中使用Deque来实现）来玩家的行走路径，在回退时弹出栈顶元素。注意栈不能为空，若栈内只有一个元素，则提示玩家已经返回到起点。

3. 随机传送。每当玩家进入这个房间，就会被随机地传输到另一个房间。

   在Room类中增加一个属性type，表示是否为随机传送的房间。

   在Game类的goRoom方法中额外判断进入的房间是否为随机传送房间，如果是，则在房间编号中随机一个作为当前房间编号。如果仍然为随机传送房间，那么继续传送。

   同时，为了避免back指令中回退到传送房间的问题，我们在玩家行动路径中不记录传送房间，如果玩家在传送后立刻使用back指令，那么将回到进入传送房间之前的房间。

   最后修改当前房间对象即可

4. Player类的相关操作。
   1. 登录操作。

      游戏初始化前先由玩家输入用户名作为登录依据，若该用户已存在，则载入数据，否则视为创建新账户。

   2. 物品携带。

      在Player类中添加一个存储物品对象的ArrayList<Item>属性bag，用于存储玩家携带的物品。

      加入表示负重的属性weight，表示承重能力的属性capacity，在获取物品时判断加入物品是否导致现有负重超过负重上限即可。

   3. 物品拾取和丢弃。

      在Player类中新增carryItem和dropItem方法。

      添加take和drop作为合法指令,并在Game类中建立对应的方法。

      在拾取时需判断房间内是否存在该物品，再判断拾取后是否会超过承重能力上限，二者同时满足才可以拾取。

      成功拾取后要在房间里清除这个物品，同时要更新玩家携带的物品，修改玩家的现有负重。

      丢弃身上的物品同理，只是不用判断重量相关。

   4. 打印物品。

      添加items作为合法指令,并建立对应的方法。遍历玩家和房间内的物品数组，分别输出其名字以及重量和即可。

   5. 魔法饼干。

      在Player类中新增eatCookie方法。

      添加eat-cookie为合法指令，在Game类中建立对应的方法。

      实现类似于drop，但是需要在背包查找特殊的“magic cookie”物品，如果没有，则提示背包内没有魔法饼干，如果有，则将该物品从背包中直接删除（而非丢弃到房间内）。

   同时为实现这些功能，对项目中的其他属性和方法进行了一系列的修改。

5. 文件存储。

   在6.2.2中已经提及，我们将地图信息分离到文件中进行存储，并通过读取文件的方式加载地图。

   现在对地图设计进行介绍

   ```
   文件中存放地图的格式应当为：
   第一行有一个正整数roomNum表示房间的个数
   之后对于每个房间
   第一行有一个字符串description表示房间的介绍
   第二行有一个整数roomType(1/0)表示该房间是/不是一个传送房间
   下一行有一个非负整数exitNum表示该房间的出口个数
   之后exitNum行每行包含一个字符串direction和一个数字exitId,中间由一个空格隔开，表示出口的房间以及出口房间的编号
   下一行由一个非负整数itemNum表示该房间内的物品个数
   之后每个item的信息包含在三行内
   第一行一个字符串itemName表示物品名称
   第二行一个字符串itemDescription表示物品介绍
   第三行一个正整数weight表示物品重量
   注意：文件内的地图必须严格按照如上格式存储，否则会报错。
   ```

   在这种设计下，我们对于地图的修改将变得极其方便，例如，如果我想在第一个房间中添加一个物品，则只需要将这个房间的itemNum属性加1，并在下面添加三行信息即可；如果我想为它添加一个出口，也只需要将exitNum加1并添加一行出口描述即可。相较于原来的createRooms方法，新的initMap在各方面都更加的优秀。

6. 数据库相关。

   我们将用户信息存储到数据库中。

   若数据库中查询不到对应用户名，则视作新用户登录，在数据库存相关信息后，为该用户分配默认的起始地点和负重上限；若数据库存在用户名，则从数据库中读取上次玩家退出时的地点和负重上限。

   同时，与该修改相关联的，在quit操作中，我们在游戏结束前会根据玩家当前状态更新数据库内的存档。

以上内容中不详尽的地方，具体实现细节均可见项目源码及代码注释。

### 6.4测试结果

1. 白盒测试。

   以ParserTest为例

```java
public class ParserTest {
    @Test
    public void getCommand() {
        String s="go east";
        ByteArrayInputStream strIn=new ByteArrayInputStream(s.getBytes());
        System.setIn(strIn);
        try{
            Command cmd=new Parser().getCommand();
            if(cmd.getCommandWord().equals("go")&&cmd.getSecondWord().equals("east")){
                System.out.println("getCommand Accepted");
            }else{
                System.out.println("getCommand Error");
            }
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
```

​		我们为控制台设置读入流strIn，调用Parser中的getCommand方法来分析该输入，如果分析结果符合预期，那么说明没有问题，如果不符合则说明该方法有误。

​		测试结果如下，测试成功：

[![J-9-IPM1-T-BANQ3-266-C.png](https://i.postimg.cc/bY5DSGbG/J-9-IPM1-T-BANQ3-266-C.png)](https://postimg.cc/BtxQdnms)

2. 黑盒测试。

   我们为项目设计这样的测试流程

   ```
   0.在Map.txt中完成地图设计，在地图上添加若干物品，具体内容见文件。
   1.运行项目。
   2.创建新账号test
   3.help查看指令集
   4.go south向南走
   5.back回退
   6.go north向北走进入传送房间
   7.back回退
   8.look查看房间信息
   9.take 0拾取apple
   10.take 0拾取stone
   11.items查看背包及地上的物品
   12.drop 0丢弃apple
   13.eat-cookie吃饼干
   14.go east向东走
   15.look查看房间信息
   16.take 0拾取magic cookie
   17.eat-cookie吃饼干
   18.go east向东走
   19.back回退
   20.take 1拾取apple
   21.take 0拾取stone
   22.back回退
   23.take 0拾取无效物品
   24.drop 2丢弃无效物品
   26.go south去南方的房间
   25.quit退出游戏。
26.再次运行项目，登录test账号
   27.look查看当前房间信息
   ```
   
   那么上述流程的期望结果应当为 
   
   ```
   1.弹出登录提示
   2.提示新用户创建成功
   3.显示指令集
   4.进入南方的房间lab
   5.回到起点outside
   6.随机传送
   7.回到起点
   8.显示房间信息及房间内物品列表
   9.成功拾取apple
   10.无法拾取stone因为体力不足。
   11.显示背包内有一个apple，地上有一个stone
   12.成功丢弃apple
   13.提示没有饼干
   14.进入东方的房间theater
   15.显示房间信息，房间内有一个magic cookie
   16.成功拾取magic cookie
   17.成功吃饼干，提示承重能力提高
   18.提示无法向东走
   19.回到起点
   20.成功拾取apple
   21.成功拾取stone
   22.提示已经在起点
   23.提示房间内没有该物品
   24.提示背包内没有该物品
   25.提示已存档，退出游戏。
   26.提示欢迎回来
   27.发现当前的房间是退出时所在的房间lab。
   ```

   该测试过程将在视频中进行展示，该流程操作图片过多，不在此进行展示。

### 6.5提交情况

如图，为最后一次提交之前的提交，报告完成后将进行最终的提交。

[![CE9-J5-KB4-F-PH7-CPVDS1-Q4-X.png](https://i.postimg.cc/wjgmgCLF/CE9-J5-KB4-F-PH7-CPVDS1-Q4-X.png)](https://postimg.cc/HVvxtPS7)

## 7.实施过程问题记录与分析

1. GitHub相关问题

   Q.在clone到本地过程中，发现该仓库受保护，无法进行clone

   A.将课堂内的项目设为public并fork到自己账号的仓库内，并在idea中关联自己的GitHub账号，即可进行clone。

2. git相关问题

   Q.在一次提交中，误点到了“修改”，导致出现期望以外的分支，并且在后续无法正常推送。

   A.在推送过程中，选择“合并”，因为是单人开发，选择“以我为主”，之后再次进行推送即可正常提交，且git中的意外分支重新合并到了-master分支中。

3. 项目实现问题

   Q.在将createRooms方法升级为initMap时，运行项目后出现NullPointerException。

   A.原来的createRooms方法内逐个定义了每个房间对象，而替换为initMap后，房间对象列表并没有初始化，也就是说在构造方法中，需要将RoomList的初始化前置，将initMap后置。

   

   Q.对于Room类，在创建地图时我们需要添加新的物品对象，但是在游戏运行过程中，我们则需要添加已有的物品对象。

   A.利用Java多态的性质

   ```java
   public void addItem(Item item);
   public void addItem(String name,String description,int weight);
   ```

   来解决这一问题

## 8.任务总结

​	本次实践任务的完整开发周期约一周，虽然并不是第一次使用GitHub，但却是第一次利用git来进行版本控制，对于很多GitHub的操作以及git命令都并不熟悉，但是在通过查阅各种资料以及自行摸索后，最终解决了所有的问题。

​	在此次实验中我的收获很多：

1. 学习了如何利用GitHub进行项目开发。无论是在未来的课设/毕设还是工作中，GitHub都将占据重要的地位，学习并掌握相关知识是非常必要的。
2. 通过阅读文档，学习了很多开发规范，如命名、 版本号、提交等等方面。
3. 通过对java的使用加深了对于面向对象开发的理解，以及对于java语言的特性有了更深入的认识。
4. 通过对于文件存储格式的设计以及数据库的设计，强化了用不同的手段来优化代码的能力。
5. 通过使用IDEA，对这一集成开发工具有了更娴熟的掌握，在以后的开发中也能更快更好的编写高质量的代码。

## 9.参考文献

1. [基于 angular 规范的 commit](https://www.shuzhiduo.com/A/lk5amGwZ51/)
2. [Idea中Junit进行方法测试详解](https://blog.csdn.net/qq_44762290/article/details/109124772)
3. [在IDEA上进行JUnit测试](https://blog.csdn.net/qq_44028290/article/details/108903857)
4. 阿里巴巴《JAVA开发手册（嵩山版）》





